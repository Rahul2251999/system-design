<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implementation: Microservices Architecture | System Design A-Z</title>
    <meta name="description" content="Practical implementation guide for microservices architecture with code examples and best practices">
    <link rel="stylesheet" href="../../css/normalize.css">
    <link rel="stylesheet" href="../../css/styles.css">
    <link rel="stylesheet" href="../../css/implementation.css">
    <link rel="stylesheet" href="../../css/content-page.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>
    <header class="site-header">
        <div class="container">
            <div class="logo">
                <a href="../../index.html">
                    <span class="logo-text">System Design <span class="highlight">A-Z</span></span>
                </a>
            </div>
            <nav class="main-nav">
                <button class="menu-toggle" aria-label="Toggle menu">
                    <span class="hamburger"></span>
                </button>
                <ul class="nav-links">
                    <li><a href="../../index.html">Home</a></li>
                    <li><a href="../fundamentals/index.html">Fundamentals</a></li>
                    <li><a href="../examples/index.html">Real-World Examples</a></li>
                    <li><a href="../implementation/index.html" class="active">Implementation</a></li>
                    <li><a href="../../index.html#about">About</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main class="content-page">
        <div class="container">
            <div class="content-wrapper">
                <aside class="sidebar">
                    <div class="sidebar-content">
                        <h3>Implementation Guides</h3>
                        <ul class="sidebar-nav">
                            <li><a href="microservices.html" class="active">Microservices Architecture</a></li>
                            <li><a href="load-balancing.html">Load Balancing</a></li>
                            <li><a href="caching-strategies.html">Caching Strategies</a></li>
                            <li><a href="database-sharding.html">Database Sharding</a></li>
                            <li><a href="api-gateway.html">API Gateway</a></li>
                            <li><a href="message-queues.html">Message Queues</a></li>
                            <li><a href="service-discovery.html">Service Discovery</a></li>
                            <li><a href="authentication.html">Authentication & Authorization</a></li>
                            <li><a href="monitoring.html">Monitoring & Logging</a></li>
                            <li><a href="ci-cd.html">CI/CD Pipeline</a></li>
                        </ul>
                        <div class="sidebar-cta">
                            <h4>See it in action</h4>
                            <p>Check out real-world examples</p>
                            <a href="../examples/index.html" class="btn btn-sm">View Examples</a>
                        </div>
                    </div>
                </aside>

                <article class="main-content">
                    <div class="content-header">
                        <h1>Implementing Microservices Architecture</h1>
                        <div class="content-meta">
                            <span class="difficulty intermediate">Intermediate</span>
                            <span class="reading-time">20 min read</span>
                        </div>
                    </div>

                    <div class="content-body">
                        <section class="content-section">
                            <h2>Introduction to Microservices Implementation</h2>
                            <p>Microservices architecture has become the standard approach for building scalable, maintainable, and resilient applications. Unlike monolithic applications where all components are tightly coupled, microservices break down an application into smaller, independent services that communicate through well-defined APIs.</p>
                            
                            <p>In this implementation guide, we'll walk through the practical aspects of building a microservices-based system, covering everything from service design to deployment and monitoring. We'll use a combination of Node.js, Docker, and Kubernetes to demonstrate these concepts.</p>
                            
                            <div class="image-container">
                                <div class="placeholder-image">
                                    <p>Microservices Architecture Diagram</p>
                                </div>
                                <div class="image-caption">Figure 1: High-level architecture of a microservices-based system.</div>
                            </div>
                        </section>

                        <section class="content-section">
                            <h2>Prerequisites</h2>
                            <p>Before we begin implementing microservices, ensure you have the following tools installed:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block bash">
# Check Node.js version (v14+ recommended)
node --version

# Check Docker version
docker --version

# Check Kubernetes CLI (kubectl)
kubectl version --client

# Check package manager
npm --version
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <p>You'll also need a basic understanding of:</p>
                            <ul>
                                <li>RESTful API design principles</li>
                                <li>JavaScript/Node.js programming</li>
                                <li>Docker containerization concepts</li>
                                <li>Basic networking concepts</li>
                            </ul>
                        </section>

                        <section class="content-section">
                            <h2>Step 1: Designing Your Microservices</h2>
                            
                            <h3>Domain-Driven Design</h3>
                            <p>The first step in implementing microservices is to identify the boundaries of each service. Domain-Driven Design (DDD) provides a framework for this by focusing on the core domain and domain logic.</p>
                            
                            <div class="info-box">
                                <h4>Key Principle</h4>
                                <p>Each microservice should have a single responsibility and represent a business capability. Services should be loosely coupled but highly cohesive.</p>
                            </div>
                            
                            <p>For our example, let's consider an e-commerce application with the following services:</p>
                            <ul>
                                <li><strong>User Service</strong>: Handles user registration, authentication, and profile management</li>
                                <li><strong>Product Service</strong>: Manages product catalog, inventory, and pricing</li>
                                <li><strong>Order Service</strong>: Processes orders, payments, and order status</li>
                                <li><strong>Notification Service</strong>: Sends emails, SMS, and push notifications</li>
                            </ul>
                            
                            <h3>Service Communication Patterns</h3>
                            <p>Decide how your services will communicate with each other. Common patterns include:</p>
                            <ul>
                                <li><strong>Synchronous REST API calls</strong>: Direct HTTP requests between services</li>
                                <li><strong>Asynchronous messaging</strong>: Using message queues like RabbitMQ or Kafka</li>
                                <li><strong>Event-driven architecture</strong>: Services publish and subscribe to events</li>
                            </ul>
                            
                            <p>For our example, we'll use a combination of REST APIs for synchronous operations and message queues for asynchronous processes.</p>
                        </section>

                        <section class="content-section">
                            <h2>Step 2: Setting Up the Project Structure</h2>
                            
                            <p>Let's create a project structure for our microservices:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block bash">
mkdir ecommerce-microservices
cd ecommerce-microservices

# Create directories for each service
mkdir -p user-service product-service order-service notification-service

# Create shared libraries directory
mkdir -p shared-libs
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <p>Each service should have its own repository in a real-world scenario, but for this example, we'll keep them in a single repository for simplicity.</p>
                            
                            <h3>Service Template</h3>
                            <p>Let's create a basic template for our Node.js microservices:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block bash">
# Navigate to user service directory
cd user-service

# Initialize npm project
npm init -y

# Install dependencies
npm install express mongoose dotenv winston cors helmet

# Create basic directory structure
mkdir -p src/controllers src/models src/routes src/middleware src/config
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <p>Repeat this process for each service, adjusting dependencies as needed.</p>
                        </section>

                        <section class="content-section">
                            <h2>Step 3: Implementing a Microservice</h2>
                            
                            <p>Let's implement the User Service as an example. First, create the main application file:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// src/app.js
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const routes = require('./routes');
const config = require('./config');
const logger = require('./config/logger');

const app = express();

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());

// Request logging
app.use((req, res, next) => {
  logger.info(`${req.method} ${req.url}`);
  next();
});

// Routes
app.use('/api/users', routes.userRoutes);
app.use('/api/auth', routes.authRoutes);

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'UP' });
});

// Error handling middleware
app.use((err, req, res, next) => {
  logger.error(err.stack);
  res.status(500).json({
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'production' ? 'Something went wrong' : err.message
  });
});

// Database connection
mongoose.connect(config.database.url, config.database.options)
  .then(() => {
    logger.info('Connected to MongoDB');
    app.listen(config.server.port, () => {
      logger.info(`User service running on port ${config.server.port}`);
    });
  })
  .catch(err => {
    logger.error('Database connection error:', err);
    process.exit(1);
  });

module.exports = app;
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <h3>Configuration</h3>
                            <p>Create a configuration file to manage environment-specific settings:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// src/config/index.js
require('dotenv').config();

module.exports = {
  server: {
    port: process.env.PORT || 3000,
    env: process.env.NODE_ENV || 'development'
  },
  database: {
    url: process.env.MONGODB_URI || 'mongodb://localhost:27017/user-service',
    options: {
      useNewUrlParser: true,
      useUnifiedTopology: true
    }
  },
  jwt: {
    secret: process.env.JWT_SECRET || 'your-secret-key',
    expiresIn: process.env.JWT_EXPIRES_IN || '1d'
  },
  services: {
    product: process.env.PRODUCT_SERVICE_URL || 'http://localhost:3001',
    order: process.env.ORDER_SERVICE_URL || 'http://localhost:3002',
    notification: process.env.NOTIFICATION_SERVICE_URL || 'http://localhost:3003'
  }
};
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <h3>User Model</h3>
                            <p>Create a user model using Mongoose:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// src/models/user.model.js
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
    trim: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  name: {
    type: String,
    required: true,
    trim: true
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  isActive: {
    type: Boolean,
    default: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Method to compare passwords
userSchema.methods.comparePassword = async function(candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

const User = mongoose.model('User', userSchema);

module.exports = User;
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <h3>User Controller</h3>
                            <p>Implement the controller for user operations:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// src/controllers/user.controller.js
const User = require('../models/user.model');
const logger = require('../config/logger');

exports.createUser = async (req, res) => {
  try {
    const { email, password, name } = req.body;
    
    // Check if user already exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(409).json({ message: 'User already exists' });
    }
    
    // Create new user
    const user = new User({ email, password, name });
    await user.save();
    
    // Remove password from response
    const userResponse = user.toObject();
    delete userResponse.password;
    
    res.status(201).json(userResponse);
  } catch (error) {
    logger.error('Error creating user:', error);
    res.status(500).json({ message: 'Error creating user' });
  }
};

exports.getUsers = async (req, res) => {
  try {
    const users = await User.find({}, '-password');
    res.status(200).json(users);
  } catch (error) {
    logger.error('Error fetching users:', error);
    res.status(500).json({ message: 'Error fetching users' });
  }
};

exports.getUserById = async (req, res) => {
  try {
    const user = await User.findById(req.params.id, '-password');
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    res.status(200).json(user);
  } catch (error) {
    logger.error('Error fetching user:', error);
    res.status(500).json({ message: 'Error fetching user' });
  }
};

exports.updateUser = async (req, res) => {
  try {
    const { name, email } = req.body;
    
    const user = await User.findByIdAndUpdate(
      req.params.id,
      { name, email, updatedAt: Date.now() },
      { new: true, runValidators: true, select: '-password' }
    );
    
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    res.status(200).json(user);
  } catch (error) {
    logger.error('Error updating user:', error);
    res.status(500).json({ message: 'Error updating user' });
  }
};

exports.deleteUser = async (req, res) => {
  try {
    const user = await User.findByIdAndDelete(req.params.id);
    
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    res.status(204).send();
  } catch (error) {
    logger.error('Error deleting user:', error);
    res.status(500).json({ message: 'Error deleting user' });
  }
};
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <h3>Authentication Controller</h3>
                            <p>Implement authentication functionality:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// src/controllers/auth.controller.js
const jwt = require('jsonwebtoken');
const User = require('../models/user.model');
const config = require('../config');
const logger = require('../config/logger');

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Find user by email
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    // Check if password is correct
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    // Generate JWT token
    const token = jwt.sign(
      { id: user._id, email: user.email, role: user.role },
      config.jwt.secret,
      { expiresIn: config.jwt.expiresIn }
    );
    
    res.status(200).json({
      token,
      user: {
        id: user._id,
        email: user.email,
        name: user.name,
        role: user.role
      }
    });
  } catch (error) {
    logger.error('Login error:', error);
    res.status(500).json({ message: 'Error during login' });
  }
};

exports.register = async (req, res) => {
  try {
    const { email, password, name } = req.body;
    
    // Check if user already exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(409).json({ message: 'User already exists' });
    }
    
    // Create new user
    const user = new User({ email, password, name });
    await user.save();
    
    // Generate JWT token
    const token = jwt.sign(
      { id: user._id, email: user.email, role: user.role },
      config.jwt.secret,
      { expiresIn: config.jwt.expiresIn }
    );
    
    res.status(201).json({
      token,
      user: {
        id: user._id,
        email: user.email,
        name: user.name,
        role: user.role
      }
    });
  } catch (error) {
    logger.error('Registration error:', error);
    res.status(500).json({ message: 'Error during registration' });
  }
};

exports.me = async (req, res) => {
  try {
    const user = await User.findById(req.user.id, '-password');
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    res.status(200).json(user);
  } catch (error) {
    logger.error('Error fetching user profile:', error);
    res.status(500).json({ message: 'Error fetching user profile' });
  }
};
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <h3>Authentication Middleware</h3>
                            <p>Create middleware to protect routes:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// src/middleware/auth.middleware.js
const jwt = require('jsonwebtoken');
const config = require('../config');

exports.authenticate = (req, res, next) => {
  // Get token from header
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'No token provided' });
  }
  
  const token = authHeader.split(' ')[1];
  
  try {
    // Verify token
    const decoded = jwt.verify(token, config.jwt.secret);
    
    // Add user info to request
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ message: 'Invalid token' });
  }
};

exports.authorize = (roles = []) => {
  if (typeof roles === 'string') {
    roles = [roles];
  }
  
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ message: 'Unauthorized' });
    }
    
    if (roles.length && !roles.includes(req.user.role)) {
      return res.status(403).json({ message: 'Forbidden' });
    }
    
    next();
  };
};
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <h3>Routes</h3>
                            <p>Define the API routes:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// src/routes/user.routes.js
const express = require('express');
const userController = require('../controllers/user.controller');
const authMiddleware = require('../middleware/auth.middleware');

const router = express.Router();

router.post('/', 
  authMiddleware.authenticate, 
  authMiddleware.authorize('admin'), 
  userController.createUser
);

router.get('/', 
  authMiddleware.authenticate, 
  authMiddleware.authorize('admin'), 
  userController.getUsers
);

router.get('/:id', 
  authMiddleware.authenticate, 
  userController.getUserById
);

router.put('/:id', 
  authMiddleware.authenticate, 
  userController.updateUser
);

router.delete('/:id', 
  authMiddleware.authenticate, 
  authMiddleware.authorize('admin'), 
  userController.deleteUser
);

module.exports = router;
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// src/routes/auth.routes.js
const express = require('express');
const authController = require('../controllers/auth.controller');
const authMiddleware = require('../middleware/auth.middleware');

const router = express.Router();

router.post('/login', authController.login);
router.post('/register', authController.register);
router.get('/me', authMiddleware.authenticate, authController.me);

module.exports = router;
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// src/routes/index.js
const userRoutes = require('./user.routes');
const authRoutes = require('./auth.routes');

module.exports = {
  userRoutes,
  authRoutes
};
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                        </section>

                        <section class="content-section">
                            <h2>Step 4: Containerizing the Microservice</h2>
                            
                            <p>Create a Dockerfile for the User Service:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block dockerfile">
# Dockerfile
FROM node:14-alpine

# Create app directory
WORKDIR /usr/src/app

# Install app dependencies
COPY package*.json ./
RUN npm install

# Bundle app source
COPY . .

# Expose port
EXPOSE 3000

# Start command
CMD ["node", "src/app.js"]
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <p>Create a .dockerignore file to exclude unnecessary files:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block text">
# .dockerignore
node_modules
npm-debug.log
.git
.env
.DS_Store
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <p>Build and run the Docker container:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block bash">
# Build the Docker image
docker build -t user-service .

# Run the container
docker run -p 3000:3000 --name user-service \
  -e MONGODB_URI=mongodb://host.docker.internal:27017/user-service \
  -e JWT_SECRET=your-secret-key \
  -d user-service
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                        </section>

                        <section class="content-section">
                            <h2>Step 5: Service-to-Service Communication</h2>
                            
                            <h3>REST API Communication</h3>
                            <p>For synchronous communication between services, we can use HTTP requests. Let's create a service client:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// src/services/product-service-client.js
const axios = require('axios');
const config = require('../config');
const logger = require('../config/logger');

class ProductServiceClient {
  constructor() {
    this.baseURL = config.services.product;
    this.client = axios.create({
      baseURL: this.baseURL,
      timeout: 5000,
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }
  
  async getProduct(productId) {
    try {
      const response = await this.client.get(`/api/products/${productId}`);
      return response.data;
    } catch (error) {
      logger.error(`Error fetching product ${productId}:`, error);
      throw new Error(`Failed to fetch product: ${error.message}`);
    }
  }
  
  async getProducts(filters = {}) {
    try {
      const response = await this.client.get('/api/products', { params: filters });
      return response.data;
    } catch (error) {
      logger.error('Error fetching products:', error);
      throw new Error(`Failed to fetch products: ${error.message}`);
    }
  }
}

module.exports = new ProductServiceClient();
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <h3>Asynchronous Communication with Message Queues</h3>
                            <p>For asynchronous communication, let's set up a message producer using RabbitMQ:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// src/services/message-broker.js
const amqp = require('amqplib');
const config = require('../config');
const logger = require('../config/logger');

class MessageBroker {
  constructor() {
    this.connection = null;
    this.channel = null;
    this.url = config.rabbitmq.url || 'amqp://localhost';
  }
  
  async connect() {
    try {
      this.connection = await amqp.connect(this.url);
      this.channel = await this.connection.createChannel();
      logger.info('Connected to RabbitMQ');
    } catch (error) {
      logger.error('Error connecting to RabbitMQ:', error);
      throw error;
    }
  }
  
  async publishMessage(exchange, routingKey, message) {
    if (!this.channel) {
      await this.connect();
    }
    
    try {
      await this.channel.assertExchange(exchange, 'topic', { durable: true });
      
      this.channel.publish(
        exchange,
        routingKey,
        Buffer.from(JSON.stringify(message)),
        { persistent: true }
      );
      
      logger.info(`Message published to ${exchange} with routing key ${routingKey}`);
    } catch (error) {
      logger.error('Error publishing message:', error);
      throw error;
    }
  }
  
  async consumeMessages(exchange, queue, routingKey, callback) {
    if (!this.channel) {
      await this.connect();
    }
    
    try {
      await this.channel.assertExchange(exchange, 'topic', { durable: true });
      const q = await this.channel.assertQueue(queue, { durable: true });
      
      await this.channel.bindQueue(q.queue, exchange, routingKey);
      
      this.channel.consume(q.queue, (msg) => {
        if (msg !== null) {
          const content = JSON.parse(msg.content.toString());
          callback(content);
          this.channel.ack(msg);
        }
      });
      
      logger.info(`Consuming messages from ${queue} with routing key ${routingKey}`);
    } catch (error) {
      logger.error('Error consuming messages:', error);
      throw error;
    }
  }
  
  async close() {
    try {
      await this.channel.close();
      await this.connection.close();
      logger.info('Closed RabbitMQ connection');
    } catch (error) {
      logger.error('Error closing RabbitMQ connection:', error);
    }
  }
}

module.exports = new MessageBroker();
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <p>Now, let's use this message broker to notify other services when a user is created:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// Update src/controllers/user.controller.js
const User = require('../models/user.model');
const logger = require('../config/logger');
const messageBroker = require('../services/message-broker');

exports.createUser = async (req, res) => {
  try {
    const { email, password, name } = req.body;
    
    // Check if user already exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(409).json({ message: 'User already exists' });
    }
    
    // Create new user
    const user = new User({ email, password, name });
    await user.save();
    
    // Remove password from response
    const userResponse = user.toObject();
    delete userResponse.password;
    
    // Publish user created event
    await messageBroker.publishMessage(
      'user-events',
      'user.created',
      {
        id: user._id,
        email: user.email,
        name: user.name,
        createdAt: user.createdAt
      }
    );
    
    res.status(201).json(userResponse);
  } catch (error) {
    logger.error('Error creating user:', error);
    res.status(500).json({ message: 'Error creating user' });
  }
};
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                        </section>

                        <section class="content-section">
                            <h2>Step 6: Deploying to Kubernetes</h2>
                            
                            <p>Create Kubernetes deployment and service files for the User Service:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block yaml">
# kubernetes/user-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  labels:
    app: user-service
spec:
  replicas: 2
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: user-service:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 3000
        env:
        - name: MONGODB_URI
          valueFrom:
            configMapKeyRef:
              name: microservices-config
              key: mongodb-uri
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: microservices-secrets
              key: jwt-secret
        - name: PRODUCT_SERVICE_URL
          value: "http://product-service:3000"
        - name: ORDER_SERVICE_URL
          value: "http://order-service:3000"
        - name: NOTIFICATION_SERVICE_URL
          value: "http://notification-service:3000"
        - name: RABBITMQ_URL
          value: "amqp://rabbitmq:5672"
        resources:
          limits:
            cpu: "0.5"
            memory: "512Mi"
          requests:
            cpu: "0.2"
            memory: "256Mi"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <div class="code-block-container">
                                <pre class="code-block yaml">
# kubernetes/user-service-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
  - port: 3000
    targetPort: 3000
  type: ClusterIP
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <p>Create ConfigMap and Secret for configuration:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block yaml">
# kubernetes/config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: microservices-config
data:
  mongodb-uri: "mongodb://mongodb:27017/user-service"
---
apiVersion: v1
kind: Secret
metadata:
  name: microservices-secrets
type: Opaque
data:
  jwt-secret: c2VjcmV0LWtleS1mb3ItbWljcm9zZXJ2aWNlcw== # base64 encoded "secret-key-for-microservices"
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <p>Apply the Kubernetes configurations:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block bash">
# Apply ConfigMap and Secret
kubectl apply -f kubernetes/config.yaml

# Apply User Service deployment and service
kubectl apply -f kubernetes/user-service-deployment.yaml
kubectl apply -f kubernetes/user-service-service.yaml
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                        </section>

                        <section class="content-section">
                            <h2>Step 7: API Gateway</h2>
                            
                            <p>An API Gateway serves as a single entry point for all client requests, routing them to the appropriate microservices. Let's implement a simple API Gateway using Node.js and Express:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// api-gateway/src/app.js
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const config = require('./config');
const logger = require('./config/logger');
const authMiddleware = require('./middleware/auth.middleware');

const app = express();

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later'
});
app.use(limiter);

// Request logging
app.use((req, res, next) => {
  logger.info(`${req.method} ${req.url}`);
  next();
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'UP' });
});

// Routes
// User Service
app.use('/api/users', 
  authMiddleware.authenticate,
  createProxyMiddleware({
    target: config.services.user,
    changeOrigin: true,
    pathRewrite: {
      '^/api/users': '/api/users'
    }
  })
);

app.use('/api/auth', 
  createProxyMiddleware({
    target: config.services.user,
    changeOrigin: true,
    pathRewrite: {
      '^/api/auth': '/api/auth'
    }
  })
);

// Product Service
app.use('/api/products', 
  createProxyMiddleware({
    target: config.services.product,
    changeOrigin: true,
    pathRewrite: {
      '^/api/products': '/api/products'
    }
  })
);

// Order Service
app.use('/api/orders', 
  authMiddleware.authenticate,
  createProxyMiddleware({
    target: config.services.order,
    changeOrigin: true,
    pathRewrite: {
      '^/api/orders': '/api/orders'
    }
  })
);

// Error handling middleware
app.use((err, req, res, next) => {
  logger.error(err.stack);
  res.status(500).json({
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'production' ? 'Something went wrong' : err.message
  });
});

const PORT = process.env.PORT || 4000;
app.listen(PORT, () => {
  logger.info(`API Gateway running on port ${PORT}`);
});

module.exports = app;
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <p>Create a Dockerfile for the API Gateway:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block dockerfile">
# api-gateway/Dockerfile
FROM node:14-alpine

WORKDIR /usr/src/app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 4000

CMD ["node", "src/app.js"]
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <p>Create Kubernetes deployment and service for the API Gateway:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block yaml">
# kubernetes/api-gateway-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-gateway
  labels:
    app: api-gateway
spec:
  replicas: 2
  selector:
    matchLabels:
      app: api-gateway
  template:
    metadata:
      labels:
        app: api-gateway
    spec:
      containers:
      - name: api-gateway
        image: api-gateway:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 4000
        env:
        - name: USER_SERVICE_URL
          value: "http://user-service:3000"
        - name: PRODUCT_SERVICE_URL
          value: "http://product-service:3000"
        - name: ORDER_SERVICE_URL
          value: "http://order-service:3000"
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: microservices-secrets
              key: jwt-secret
        resources:
          limits:
            cpu: "0.5"
            memory: "512Mi"
          requests:
            cpu: "0.2"
            memory: "256Mi"
        livenessProbe:
          httpGet:
            path: /health
            port: 4000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 4000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: api-gateway
spec:
  selector:
    app: api-gateway
  ports:
  - port: 80
    targetPort: 4000
  type: LoadBalancer
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                        </section>

                        <section class="content-section">
                            <h2>Step 8: Monitoring and Logging</h2>
                            
                            <p>Set up monitoring and logging for your microservices using Prometheus and ELK Stack:</p>
                            
                            <h3>Prometheus Metrics</h3>
                            <p>Add Prometheus metrics to your services:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// src/middleware/metrics.middleware.js
const promClient = require('prom-client');
const collectDefaultMetrics = promClient.collectDefaultMetrics;

// Create a Registry to register the metrics
const register = new promClient.Registry();
collectDefaultMetrics({ register });

// Create custom metrics
const httpRequestDurationMicroseconds = new promClient.Histogram({
  name: 'http_request_duration_ms',
  help: 'Duration of HTTP requests in ms',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [0.1, 5, 15, 50, 100, 500]
});

const httpRequestCounter = new promClient.Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status_code']
});

// Register the metrics
register.registerMetric(httpRequestDurationMicroseconds);
register.registerMetric(httpRequestCounter);

// Middleware function to collect metrics
function metricsMiddleware(req, res, next) {
  const start = Date.now();
  
  // Record end time and calculate duration on response finish
  res.on('finish', () => {
    const duration = Date.now() - start;
    const route = req.route ? req.route.path : req.path;
    
    // Observe metrics
    httpRequestDurationMicroseconds
      .labels(req.method, route, res.statusCode)
      .observe(duration);
    
    httpRequestCounter
      .labels(req.method, route, res.statusCode)
      .inc();
  });
  
  next();
}

// Endpoint to expose metrics
function metricsEndpoint(req, res) {
  res.set('Content-Type', register.contentType);
  res.end(register.metrics());
}

module.exports = {
  metricsMiddleware,
  metricsEndpoint
};
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <p>Add the metrics middleware to your application:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// Update src/app.js
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const routes = require('./routes');
const config = require('./config');
const logger = require('./config/logger');
const { metricsMiddleware, metricsEndpoint } = require('./middleware/metrics.middleware');

const app = express();

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(metricsMiddleware); // Add metrics middleware

// Request logging
app.use((req, res, next) => {
  logger.info(`${req.method} ${req.url}`);
  next();
});

// Routes
app.use('/api/users', routes.userRoutes);
app.use('/api/auth', routes.authRoutes);

// Metrics endpoint
app.get('/metrics', metricsEndpoint);

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'UP' });
});

// ... rest of the code
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                            
                            <h3>Centralized Logging with ELK Stack</h3>
                            <p>Configure your logger to send logs to Elasticsearch:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block javascript">
// src/config/logger.js
const winston = require('winston');
const { ElasticsearchTransport } = require('winston-elasticsearch');

const esTransportOpts = {
  level: 'info',
  clientOpts: {
    node: process.env.ELASTICSEARCH_URL || 'http://localhost:9200',
    auth: {
      username: process.env.ELASTICSEARCH_USERNAME,
      password: process.env.ELASTICSEARCH_PASSWORD
    }
  },
  indexPrefix: 'user-service-logs'
};

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  defaultMeta: { service: 'user-service' },
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    })
  ]
});

// Add Elasticsearch transport in production
if (process.env.NODE_ENV === 'production') {
  logger.add(new ElasticsearchTransport(esTransportOpts));
}

module.exports = logger;
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                        </section>

                        <section class="content-section">
                            <h2>Step 9: CI/CD Pipeline</h2>
                            
                            <p>Set up a CI/CD pipeline using GitHub Actions:</p>
                            
                            <div class="code-block-container">
                                <pre class="code-block yaml">
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
        
    - name: Install dependencies
      run: |
        cd user-service
        npm ci
        
    - name: Run tests
      run: |
        cd user-service
        npm test
        
    - name: Build Docker image
      run: |
        cd user-service
        docker build -t user-service:${{ github.sha }} .
        
    - name: Run container tests
      run: |
        docker run --name user-service-test -d user-service:${{ github.sha }}
        docker exec user-service-test npm test
        docker stop user-service-test
        docker rm user-service-test
        
  deploy:
    needs: build-and-test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up kubectl
      uses: azure/setup-kubectl@v1
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2
        
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
      
    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: user-service
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd user-service
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
    - name: Update kube config
      run: aws eks update-kubeconfig --name microservices-cluster --region us-west-2
      
    - name: Deploy to EKS
      run: |
        cd kubernetes
        sed -i "s|image: user-service:latest|image: ${{ steps.login-ecr.outputs.registry }}/user-service:${{ github.sha }}|g" user-service-deployment.yaml
        kubectl apply -f user-service-deployment.yaml
</pre>
                                <div class="copy-button" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </div>
                            </div>
                        </section>

                        <section class="content-section">
                            <h2>Best Practices for Microservices</h2>
                            
                            <div class="best-practices">
                                <div class="practice">
                                    <h3>1. Single Responsibility</h3>
                                    <p>Each microservice should focus on a single business capability and have a clear boundary.</p>
                                </div>
                                
                                <div class="practice">
                                    <h3>2. Database per Service</h3>
                                    <p>Each microservice should own its data and have its own database. This ensures loose coupling and independent scaling.</p>
                                </div>
                                
                                <div class="practice">
                                    <h3>3. API First Design</h3>
                                    <p>Design your APIs before implementing the services. Use tools like Swagger/OpenAPI for documentation.</p>
                                </div>
                                
                                <div class="practice">
                                    <h3>4. Resilience and Fault Tolerance</h3>
                                    <p>Implement circuit breakers, retries, and fallbacks to handle failures gracefully.</p>
                                </div>
                                
                                <div class="practice">
                                    <h3>5. Centralized Logging and Monitoring</h3>
                                    <p>Implement comprehensive logging and monitoring to track service health and troubleshoot issues.</p>
                                </div>
                                
                                <div class="practice">
                                    <h3>6. Automated Testing</h3>
                                    <p>Implement unit, integration, and contract tests to ensure service reliability.</p>
                                </div>
                                
                                <div class="practice">
                                    <h3>7. CI/CD Pipeline</h3>
                                    <p>Automate the build, test, and deployment process to enable frequent and reliable releases.</p>
                                </div>
                                
                                <div class="practice">
                                    <h3>8. Service Discovery</h3>
                                    <p>Implement service discovery to allow services to find and communicate with each other dynamically.</p>
                                </div>
                                
                                <div class="practice">
                                    <h3>9. API Gateway</h3>
                                    <p>Use an API Gateway to provide a single entry point for clients and handle cross-cutting concerns.</p>
                                </div>
                                
                                <div class="practice">
                                    <h3>10. Containerization and Orchestration</h3>
                                    <p>Use containers and orchestration tools like Kubernetes to manage deployment, scaling, and operations.</p>
                                </div>
                            </div>
                        </section>

                        <section class="content-section">
                            <h2>Common Challenges and Solutions</h2>
                            
                            <div class="challenges">
                                <div class="challenge">
                                    <h3>Challenge: Distributed Data Management</h3>
                                    <p><strong>Problem:</strong> Managing data consistency across multiple services.</p>
                                    <p><strong>Solution:</strong> Implement eventual consistency using event-driven architecture. Use the Saga pattern for distributed transactions.</p>
                                </div>
                                
                                <div class="challenge">
                                    <h3>Challenge: Service Discovery</h3>
                                    <p><strong>Problem:</strong> Services need to find and communicate with each other.</p>
                                    <p><strong>Solution:</strong> Use service discovery tools like Consul, Eureka, or Kubernetes DNS.</p>
                                </div>
                                
                                <div class="challenge">
                                    <h3>Challenge: Monitoring and Debugging</h3>
                                    <p><strong>Problem:</strong> Tracking issues across multiple services.</p>
                                    <p><strong>Solution:</strong> Implement distributed tracing (e.g., Jaeger, Zipkin) and centralized logging (ELK Stack).</p>
                                </div>
                                
                                <div class="challenge">
                                    <h3>Challenge: Authentication and Authorization</h3>
                                    <p><strong>Problem:</strong> Securing communication between services.</p>
                                    <p><strong>Solution:</strong> Implement OAuth 2.0/JWT for authentication and use an API Gateway for centralized auth.</p>
                                </div>
                                
                                <div class="challenge">
                                    <h3>Challenge: Testing</h3>
                                    <p><strong>Problem:</strong> Testing interactions between services.</p>
                                    <p><strong>Solution:</strong> Use contract testing (e.g., Pact) and implement comprehensive integration tests.</p>
                                </div>
                            </div>
                        </section>

                        <section class="content-section">
                            <h2>Conclusion</h2>
                            <p>Implementing a microservices architecture requires careful planning and consideration of various aspects, from service design to deployment and monitoring. By following the steps and best practices outlined in this guide, you can build a scalable, maintainable, and resilient microservices-based system.</p>
                            
                            <p>Remember that microservices are not a silver bullet and come with their own set of challenges. Start small, focus on clear service boundaries, and gradually evolve your architecture as your understanding and requirements grow.</p>
                            
                            <div class="next-steps">
                                <h3>Next Steps</h3>
                                <div class="next-links">
                                    <a href="load-balancing.html" class="next-link">
                                        <span class="next-text">Next Implementation</span>
                                        <span class="next-title">Load Balancing Strategies</span>
                                        <i class="fas fa-arrow-right"></i>
                                    </a>
                                </div>
                            </div>
                        </section>
                    </div>
                </article>
            </div>
        </div>
    </main>

    <footer class="site-footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <span class="logo-text">System Design <span class="highlight">A-Z</span></span>
                </div>
                <div class="footer-links">
                    <div class="footer-nav">
                        <h4>Navigation</h4>
                        <ul>
                            <li><a href="../../index.html">Home</a></li>
                            <li><a href="../fundamentals/index.html">Fundamentals</a></li>
                            <li><a href="../examples/index.html">Real-World Examples</a></li>
                            <li><a href="../implementation/index.html">Implementation</a></li>
                        </ul>
                    </div>
                    <div class="footer-resources">
                        <h4>Resources</h4>
                        <ul>
                            <li><a href="#">Glossary</a></li>
                            <li><a href="#">Recommended Books</a></li>
                            <li><a href="#">Tools & Resources</a></li>
                            <li><a href="#">FAQ</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 System Design A-Z. All images used are copyright-free.</p>
            </div>
        </div>
    </footer>

    <script src="../../js/main.js"></script>
</body>
</html>
